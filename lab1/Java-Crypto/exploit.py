import argparse

BLOCKSIZE = 16

def do_xor(n1, n2):
    """
    xor strings utility 
    """
    n = ""   
    for i, j in zip(n1, n2):
        n += chr(ord(i) ^ ord(j))
    return n

def goECB(input_file, output_file):
    source = 54
    target = 27

    buff = ""
    # read encrypted file
    with open(input_file, "r") as f:
        buff = f.read()

    # substitute the target block (27) for with the source block (54)
    # FIXME: newline?
    buff = "".join([
        buff[:BLOCKSIZE*target],
        buff[BLOCKSIZE*source : BLOCKSIZE*source + BLOCKSIZE],
        buff[BLOCKSIZE*target + BLOCKSIZE:]
    ])

    # save changes to file
    with open(output_file, "w") as f:
        buff = f.write(buff)


def goOFB(input_file, output_file):
    target = 27

    buff = ""
    # read encrypted file
    with open(input_file, "r") as f:
        buff = f.read()

    original = "11             \n"
    wanted   = "21             \n"
    xored = do_xor(original, wanted)

    # xor(xor(a, b), a) = b and xor(xor(a, b), b) = a
    buff = "".join([
        buff[:BLOCKSIZE*target],
        do_xor(xored, buff[BLOCKSIZE*target : BLOCKSIZE*target + BLOCKSIZE]),
        buff[BLOCKSIZE*target+BLOCKSIZE:]
    ])

    # save to file
    with open(output_file, "w") as f:
        f.write(buff)


parser = argparse.ArgumentParser(description='SIRS | Lab 1 exploit script')
parser.add_argument('mode', default='ECB', help='ECB or OFB')
parser.add_argument('input_file', default='./grades.ecb.aes', help='path to input')
parser.add_argument('output_file', default='./grades.ecb.aes.2"', help='path to output')


args = parser.parse_args()

if __name__ == "__main__":
    if args.mode == "ECB":
        goECB(args.input_file, args.output_file)
    elif args.mode == "OFB":
        goOFB(args.input_file, args.output_file)
    else:
        print "Unknown mode"


