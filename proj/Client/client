#!/usr/bin/python3
import argparse
from argparse import RawTextHelpFormatter
import sys
import getpass
import ssl
import http.client
import json

# generate secure random numbers
from secrets import randbits

from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_PSS
from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Util.Padding import pad, unpad

from OpenSSL.crypto import (load_certificate, load_publickey, load_privatekey, dump_certificate, X509, X509Name, PKey)
from OpenSSL.crypto import (TYPE_RSA, FILETYPE_PEM, FILETYPE_ASN1 )

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding

from base64 import b64encode, b64decode, encodebytes

import hmac
import hashlib


class Client:

    SSL_DIR = 'ssl/'
    HOST_ADDR = 'localhost'

    CA_CERT = SSL_DIR + 'ca.crt'
    SERVER_HTTP_CERT = SSL_DIR + 'server.crt'
    CLIENT_PUB_KEY_SUBSTRING = '_public.pem'
    CLIENT_PRIV_KEY_SUBSTRING = '_private.pem'

    # Diffie-Hellman constants
    G = 2
    P = 2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919

    # Diffie-Hellman secret values
    # Sc - client secret value
    Sc = None

    # Diffie-Hellman keys
    # Kc - client key
    Kc = None
    # Ks - server key
    Ks = None
    # K - key secret value
    K = None

    server_iv = None
    client_iv = None

    session_id = None

    # loads certificates from CA for tls and server for http
    def __init__(self):
        with open(self.CA_CERT, "r") as ca_cert_file:
            ca_cert_txt = ca_cert_file.read()
        self.ca_cert = load_certificate(FILETYPE_PEM, ca_cert_txt)

        with open(self.SERVER_HTTP_CERT, "r") as server_cert_file:
            server_cert_txt = server_cert_file.read()

        self.SERVER_HTTP_CERT = load_certificate(FILETYPE_PEM, server_cert_txt)

        self.verify_certificate_chain()

    def verify_certificate_chain(self):
        # Create a certificate store and add your trusted certs (CA)
        try:
            store = crypto.X509Store()
            store.add_cert(self.ca_cert)

            # Create a certificate context using the store and the http server certificate
            store_ctx = crypto.X509StoreContext(store, self.SERVER_HTTP_CERT)

            # Verify the certificate, returns None if it can validate the certificate
            store_ctx.verify_certificate()

            return True

        except Exception as e:
            print(e)
            return False

    def create_http_tls_connection(self, method, endpoint, json_data):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=self.CA_CERT)
        # check if hostname == CA
        ssl.match_hostname = lambda cert, hostname: True

        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPSConnection(self.HOST_ADDR, context=context)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        print("Server https response: {}".format(response.read().decode()))

        return response

    def create_http_connection(self, method, endpoint, json_data):
        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPConnection(self.HOST_ADDR)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        response = response.read().decode()

        return json.loads(response)

    def create_http_request_login(self, encrypted_message_credentials, encrypted_message_key, hashed_passwd, username):
        # Sign(HMAC)
        hmac_request = self.hmac_maker(hashed_passwd, encrypted_message_credentials + encrypted_message_key)
        signature = self.sign_with_client_priv_key(username, hmac_request)
        encoded_signature = b64encode(signature).decode()
        encoded_encrypted_message_credentials = b64encode(encrypted_message_credentials).decode('utf-8')
        encoded_encrypted_message_key = b64encode(encrypted_message_key).decode('utf-8')

        #print("encrypted_message_credentials {}".format(encrypted_message_credentials.hex()))
        #print("encrypted_message_key {}".format(encrypted_message_key))
        foo = {'signature': encoded_signature,
               'hmac': hmac_request,
               'encryptedCredentials': encoded_encrypted_message_credentials,
               'encryptedKey': encoded_encrypted_message_key}
        return json.dumps(foo)

    def encrypt_with_server_pub_key(self, encoded_message):
        server_pub_key = self.SERVER_HTTP_CERT.get_pubkey().to_cryptography_key()

        print("len message to encrypt with server pub key {}".format(len(encoded_message)))
        # Optimal Asymmetric Encryption Padding (OAEP)
        return server_pub_key.encrypt(encoded_message,
                        padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                     algorithm=hashes.SHA256(),
                                     label=None))

    def hash_with_sha256_to_string(self, message):
        hashed_message = hashlib.sha256(message)
        return hashed_message.hexdigest()

    def hash_with_sha256_32_bytes(self, message):
        hashed_message = hashlib.sha256(message)
        return hashed_message.digest()

    """def hash_with_sha256(self, message):
        return hashlib.sha256(message.encode())"""

    def hmac_maker(self, hashed_passwd, encrypted_message):
        # hmac secret is hash(passwd)
        # hashed_passwd should be byte array and not str
        digest_maker = hmac.new(hashed_passwd.encode(), encrypted_message, hashlib.sha256)
        return digest_maker.hexdigest()

    def check_message_integrity(self, hmac, hashed_passwd, encrypted_content):
        content_hmac = self.hmac_maker(hashed_passwd, encrypted_content)

        if content_hmac.__eq__(hmac):
            print("message integrity checked!")
        else:
            print("message integrity not maintained!")

    def sign_with_client_priv_key(self, username, hmac_message):
        with open(self.SSL_DIR + username + self.CLIENT_PRIV_KEY_SUBSTRING, "r") as priv_key_file:
            private_key = RSA.importKey(priv_key_file.read())

        with open(self.SSL_DIR + username + self.CLIENT_PUB_KEY_SUBSTRING, "r") as server_cert_file:
            server_cert_txt = server_cert_file.read()
        publicKey = RSA.importKey(server_cert_txt)

        #print("key {}".format(publicKey.export_key()))

        print("hmac {}".format(hmac_message))
        encoded_hmac = hmac_message.encode()
        #hashed_hmac = SHA256.new(encoded_hmac)
        hashed_hmac = SHA256.new()
        hashed_hmac.update(encoded_hmac)
        print("hashed hmac {}".format(hashed_hmac.hexdigest().encode()))

        return PKCS1_PSS.new(private_key).sign(hashed_hmac)

    def generate_diffie_hellman_secret_client_value(self):
        self.Sc = randbits(256)

    def generate_diffie_hellman_client_key(self):
        self.Kc = pow(self.G, self.Sc, self.P)

    def generate_diffie_hellman_secret_key(self):
        self.K = pow(self.Ks, self.Sc, self.P)

    def decrypt_with_dh_symmetric_key(self, encrypted_message):
        # iv is going to be first 16 bytes of encrypted_message
        iv = encrypted_message[:16]
        decoded_message = encrypted_message[16:]
        print("IV: ", iv)
        print("decoded_message size: {}".format(len(decoded_message)))
        print("decoded_message: {}".format(decoded_message))
        symmetric_key = self.hash_with_sha256_32_bytes(long_to_bytes(self.K))
        cipher = AES.new(symmetric_key, AES.MODE_CBC, iv)
        #cipher = AES.new(long_to_bytes(self.Kc), AES.MODE_CBC, iv)
        return unpad(cipher.decrypt(decoded_message), AES.block_size, style='pkcs7')

    def encrypt_with_dh_symmetric_key(self, message):
        # iv is going to be first 16 bytes of encrypted_content
        iv = get_random_bytes(AES.block_size)
        symmetric_key = hash_with_sha256_to_string(long_to_bytes(self.K))
        self.cipher = AES.new(symmetric_key, AES.MODE_CBC, iv)
        return b64encode(iv + self.cipher.encrypt(pad(data.encode('utf-8'),
                                                      AES.block_size)))

    def generate_key_pair(self, username):
        client_pub_key_path = self.SSL_DIR + username + self.CLIENT_PUB_KEY_SUBSTRING
        client_priv_key_path = self.SSL_DIR + username + self.CLIENT_PRIV_KEY_SUBSTRING

        key = RSA.generate(2048)
        f = open(client_priv_key_path, "wb")
        f.write(key.exportKey('PEM'))
        f.close()

        pubkey = key.publickey()
        f = open(client_pub_key_path, "wb")
        f.write(pubkey.exportKey('PEM'))
        f.close()

    # /register
    def register(self):
        print('New Client register')

        username = input('username (max 16 characters): ')
        if len(username) > 16:
            error('username has to be shorter than 16 characters')
        passwd = getpass.getpass('password (max 32 characters: ')
        if len(passwd) > 32:
            error('passwd has to be shorter than 32 characters')
        passwd_rep = getpass.getpass('repeat password: ')

        if passwd.__eq__(passwd_rep):
            self.generate_key_pair(username)
            # can we send pub key through tls ???????????

            hashed_passwd = self.hash_with_sha256_to_string(passwd.encode())
            with open(self.SSL_DIR + username + self.CLIENT_PUB_KEY_SUBSTRING, "r") as pub_key_file:
                #public_key = RSA.importKey(pub_key_file.read())
                pub_key_text = pub_key_file.read()

            json_encoded_public_key = b64encode(pub_key_text.encode()).decode()

            foo = {'username': username,
                   'hashedPasswd': hashed_passwd,
                   'publicKey': json_encoded_public_key}
            json_data = json.dumps(foo)
            self.create_http_tls_connection('POST', '/register', json_data)
        else:
            error('passwords do not match')

    # /login
    def login(self):
        print("Client login")

        username = input('username: ')
        passwd = getpass.getpass('password: ')

        self.generate_diffie_hellman_secret_client_value()
        self.generate_diffie_hellman_client_key()

        hashed_passwd = self.hash_with_sha256_to_string(passwd.encode())
        content_credentials = username + ',' + hashed_passwd + ','
        print("content_key {}".format(self.Kc))
        content_key = long_to_bytes(self.Kc)
        print("content_key encoded {}".format(content_key))
        print("content_key decoded {}".format(content_key.decode('latin-1')))
        # last 60 bytes of the credentials are going to be part of the key
        encrypted_content_credentials = self.encrypt_with_server_pub_key(content_credentials.encode('latin-1')
                                                                         + content_key[:60])
        encrypted_content_key = self.encrypt_with_server_pub_key(content_key[60:])

        json_request = self.create_http_request_login(encrypted_content_credentials, encrypted_content_key,
                                                      hashed_passwd, username)

        response = self.create_http_connection('POST', '/login', json_request)

        print("http response: {}".format(response))

        hmac_response = response['hmac']
        encrypted_content = response['encryptedContent']
        print('encrypted_content: {}'.format(encrypted_content))
        decoded_encrypted_hmac = b64decode(encrypted_content)
        self.check_message_integrity(hmac_response, hashed_passwd, decoded_encrypted_hmac)

        # process to generate key for client to encrypt following request message
        self.Ks = int(response['dhServerKey'])
        self.generate_diffie_hellman_secret_key()
        print("secret k: {}".format(self.K))

        decrypted_content = self.decrypt_with_dh_symmetric_key(decoded_encrypted_hmac)
        print('decrypted_content: {}'.format(decrypted_content))

        self.session_id = decrypted_content.decode().split(",")[1]
        print('session id: {}'.format(self.session_id))

        # /submit
    def submit(self, vuln_description, fingerprint):
        self.login()
        print("submit")

        content = vuln_description + "," + fingerprint + "," + sessionId
        encrypted_content = self.encrypt_with_dh_symmetric_key(content)
        """hmac_request
        signature =

        foo = {'signature': ,
               'hmac': ,
              # encrypted content is going to be vuln_description + fingerprint + sessionId
               'encryptedContent': encrypted_content}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/submit', json_data)"""

    # /show
    def show(self):
        self.login()
        print("show")
        """foo = {'show': "ola"}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/show', json_data)"""

    # /score
    def score(self):
        self.login()
        print("score")

    # /admin/remove_user
    def remove_user(self):
        self.login()
        print("admin : remove_user")

    # /admin/remove_submission
    def remove_submission(self):
        self.login()
        print("admin : remove_submission")


def error(message):
    print("error: {}".format(message))
    sys.exit(1)


def main():

    client = Client()

    description = 'Welcome to the Vulnerability Submission Platform\n\
    register   Register new client account\n\
    submit     Submit vulnerability\n\
    show       Show submissions\n\
    score      Show scores\n'

    usage = '\n\
    client <command> [<args>]\n\
    client register\n\
    client submit <vuln_description> <fingerprint>\n\
    client show\n\
    client score\n'

    parser = argparse.ArgumentParser(prog='client', description=description,
                                     usage=usage, formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', type=str, choices=['register', 'submit', 'show', 'score'])
    parser.add_argument('vuln_description', nargs='?')
    parser.add_argument('fingerprint', nargs='?')

    args = parser.parse_args()

    if args.command.__eq__('register'):
        client.register()
    elif args.command.__eq__('submit'):
        if args.vuln_description and args.fingerprint:
            client.submit(args.vuln_description, args.fingerprint)
        else:
            parser.error('wrong arguments for submit command')
    elif args.command.__eq__('show'):
        client.show()
    elif args.command.__eq__('score'):
        client.score()


if __name__ == "__main__":
    main()
