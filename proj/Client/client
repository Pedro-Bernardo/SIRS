#!/usr/bin/python3
import argparse
from argparse import RawTextHelpFormatter
import sys
import getpass
import ssl
import http.client
import json

# generate secure random numbers
from secrets import randbits

from OpenSSL.crypto import (load_certificate, load_publickey, load_privatekey, dump_certificate, X509, X509Name, PKey)
from OpenSSL.crypto import (TYPE_RSA, FILETYPE_PEM, FILETYPE_ASN1 )

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding

from base64 import b64encode, b64decode, encodebytes


class Client:

    SSL_DIR = 'ssl/'
    HOST_ADDR = '127.0.0.1'

    SERVER_TLS_CERT = SSL_DIR + 'server_tls.crt'
    CLIENT_PUB_KEY_SUBSTRING = '_public.pem'
    CLIENT_PRIV_KEY_SUBSTRING = '_private.pem'

    # Diffie-Hellman constants
    G = 23
    P = 577

    # Diffie-Hellman secret values
    # Sc - client secret value
    Sc = None
    # Ss - server secret value

    # Diffie-Hellman keys
    # Kc - client key
    Kc = None
    # Ks - server key
    Ks = None
    # K - key secret value
    K = None

    def create_http_tls_connection(self, method, endpoint, json_data):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=self.SERVER_TLS_CERT)
        # check if hostname == CA
        ssl.match_hostname = lambda cert, hostname: True

        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPSConnection(self.HOST_ADDR, context=context)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        print("Server https response: {}".format(response.read().decode()))

        return response

    def create_http_connection(self, method, endpoint, json_data):
        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPConnection(self.HOST_ADDR)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        print("Server http response: {}".format(response.read().decode()))

        return response

    def encrypt_with_server_pub_key(self, message):
        # change to SERVER_CERT
        with open(self.SERVER_TLS_CERT, "r") as server_cert_file:
            server_cert_txt = server_cert_file.read()
        server_cert = load_certificate(FILETYPE_PEM, server_cert_txt)

        server_pub_key = server_cert.get_pubkey().to_cryptography_key()

        # Optimal Asymmetric Encryption Padding (OAEP)
        return b64encode(server_pub_key.encrypt(
                        message.encode('latin-1'),
                        padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                     algorithm=hashes.SHA256(),
                                     label=None))).decode('latin-1')

    def generate_diffie_hellman_secret_client_value(self):
        self.Sc = randbits(16)

    def generate_diffie_hellman_client_key(self):
        self.Kc = (self.G**self.Sc) % self.P

    def generate_diffie_hellman_secret_key(self):
        self.K = (self.Ks**self.Sc) % self.P

    # /register
    def register(self):
        print('New Client register')

        username = input('username (max 16 characters): ')
        if len(username) > 16:
            error('username has to be shorter than 16 characters')
        passwd = getpass.getpass('password (max 32 characters: ')
        if len(passwd) > 32:
            error('passwd has to be shorter than 32 characters')
        passwd_rep = getpass.getpass('repeat password: ')

        if passwd.__eq__(passwd_rep):
            foo = {'username': username, 'passwd': passwd}
            json_data = json.dumps(foo)
            self.create_http_tls_connection('POST', '/register', json_data)
        else:
            error('passwords do not match')

    # /login
    def login(self):
        print("Client login")

        username = input('username: ')
        passwd = getpass.getpass('password: ')

        self.generate_diffie_hellman_secret_client_value()
        self.generate_diffie_hellman_client_key()

        content = username + ',' + passwd + ',' + str(self.Kc)
        # Cserver,pub { username, passwd, Sc }
        foo = {'encryptedContent': self.encrypt_with_server_pub_key(content)}
        json_data = json.dumps(foo)

        response = self.create_http_connection('POST', '/login', json_data)
        """json_response = json.dumps(response)
        self.Ks = json_response['dhServerKey']
        encrypted_content = json_response['encryptedContent']

        print('ks: {} \n encrypted_content: {}'.format(self.Ks, encrypted_content))"""

    # /submit
    def submit(self, vuln_description, fingerprint):
        self.login()
        print("submit")

        foo = {'vulnDescription': vuln_description, 'fingerprint': fingerprint}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/submit', json_data)

    # /show
    def show(self):
        self.login()
        print("show")
        """foo = {'show': "ola"}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/show', json_data)"""

    # /score
    def score(self):
        self.login()
        print("score")

    # /admin/remove_user
    def remove_user(self):
        self.login()
        print("admin : remove_user")

    # /admin/remove_submission
    def remove_submission(self):
        self.login()
        print("admin : remove_submission")


def error(message):
    print("error: {}".format(message))
    sys.exit(1)


def main():

    client = Client()

    description = 'Welcome to the Vulnerability Submission Platform\n\
    register   Register new client account\n\
    submit     Submit vulnerability\n\
    show       Show submissions\n\
    score      Show scores\n'

    usage = '\n\
    client <command> [<args>]\n\
    client register\n\
    client submit <vuln_description> <fingerprint>\n\
    client show\n\
    client score\n'

    parser = argparse.ArgumentParser(prog='client', description=description,
                                     usage=usage, formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', type=str, choices=['register', 'submit', 'show', 'score'])
    parser.add_argument('vuln_description', nargs='?')
    parser.add_argument('fingerprint', nargs='?')

    args = parser.parse_args()

    if args.command.__eq__('register'):
        client.register()
    elif args.command.__eq__('submit'):
        if args.vuln_description and args.fingerprint:
            client.submit(args.vuln_description, args.fingerprint)
        else:
            parser.error('wrong arguments for submit command')
    elif args.command.__eq__('show'):
        client.show()
    elif args.command.__eq__('score'):
        client.score()


if __name__ == "__main__":
    main()