#!/usr/bin/python3
import argparse
from argparse import RawTextHelpFormatter
import sys
import getpass
import ssl
import http.client
import json

#from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

from OpenSSL.crypto import (load_certificate, load_publickey, load_privatekey, dump_certificate, X509, X509Name, PKey)
from OpenSSL.crypto import (TYPE_RSA, FILETYPE_PEM, FILETYPE_ASN1 )

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.serialization import load_pem_private_key
#from cryptography.hazmat.backends.interfaces import PEMSerializationBackend
from cryptography.hazmat.backends import default_backend

from base64 import b64encode, b64decode, encodebytes


class Client:

    SSL_DIR = 'ssl/'
    HOST_ADDR = '127.0.0.1'

    SERVER_CERT = SSL_DIR + 'server.crt'
    CLIENT_PUB_KEY_SUBSTRING = '_public.pem'
    CLIENT_PRIV_KEY_SUBSTRING = '_private.pem'

    username = ''

    def create_http_tls_connection(self, method, endpoint, json_data):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=self.SERVER_CERT)
        ssl.match_hostname = lambda cert, hostname: True

        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPSConnection(self.HOST_ADDR, context=context)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        print("Server https response: {}".format(response.read().decode()))

    def create_http_connection(self, method, endpoint, json_data):
        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPConnection(self.HOST_ADDR)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        print("Server http response: {}".format(response.read().decode()))

    # should be encrypt with user private key
    """def encrypt_with_server_pub_key(self, message):
        with open(self.SERVER_CERT, "r") as server_cert_file:
            server_cert_txt = server_cert_file.read()
        server_cert = load_certificate(FILETYPE_PEM, server_cert_txt)

        server_pub_key = server_cert.get_pubkey().to_cryptography_key()

        # Optimal Asymmetric Encryption Padding (OAEP)
        return b64encode(server_pub_key.encrypt(
                        message.encode('latin-1'),
                        padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                     algorithm=hashes.SHA256(),
                                     label=None))).decode('latin-1')"""

    def encrypt_with_client_priv_key(self, message):
        client_priv_key_path = self.SSL_DIR + self.username + self.CLIENT_PRIV_KEY_SUBSTRING
        with open(client_priv_key_path, "rb") as client_priv_file:
            client_priv_txt = client_priv_file.read()
        #client_priv_key = serialization.load_pem_private_key(client_priv_txt, password=None, backend=default_backend())
        #client_priv_key = serialization.load_pem_private_key(client_priv_txt, password=None, backend=PEMSerializationBackend)
        #client_priv_key = client_priv_txt.get_pubkey().to_cryptography_key()
        client_priv_key = RSA.importKey(client_priv_txt)
        encryptor = PKCS1_OAEP.new(client_priv_key)
        encrypted_msg = encryptor.encrypt(message.encode('latin-1'))

        return b64encode(encrypted_msg).decode('latin-1')

    def obtain_client_pub_key_encoded(self):
        client_pub_key_path = self.SSL_DIR + self.username + self.CLIENT_PUB_KEY_SUBSTRING
        with open(client_pub_key_path, "r") as client_pub_key_file:
            client_pub_key_txt = client_pub_key_file.read()

        return b64encode(client_pub_key_txt.encode()).decode()

    def generate_key_pair(self):
        client_pub_key_path = self.SSL_DIR + self.username + self.CLIENT_PUB_KEY_SUBSTRING
        client_priv_key_path = self.SSL_DIR + self.username + self.CLIENT_PRIV_KEY_SUBSTRING

        key = RSA.generate(2048)
        f = open(client_priv_key_path, "wb")
        f.write(key.exportKey('PEM'))
        f.close()

        pubkey = key.publickey()
        f = open(client_pub_key_path, "wb")
        f.write(pubkey.exportKey('PEM'))
        f.close()

    # /register
    def register(self):
        print('New Client register')

        # client's public key
        # username + password (tls)
        self.username = input('username: ')
        passwd = getpass.getpass('password: ')
        passwd_rep = getpass.getpass('repeat password: ')

        if passwd.__eq__(passwd_rep):
            self.generate_key_pair()
            foo = {'username': self.username, 'passwd': passwd, 'clientPubKey': self.obtain_client_pub_key_encoded()}
            json_data = json.dumps(foo)
            self.create_http_tls_connection('POST', '/register', json_data)
        else:
            error('passwords do not match')

    # /keygen
    """def keygen(self, username, passwd):
        print("keygen")
        encrypted_passwd = self.encrypt_with_server_pub_key(passwd.encode('latin-1'))
        print('encrypted_passwd: {}'.format(encrypted_passwd))
        # { Cpk(password), username }
        #foo = {'cipheredPasswd':  b64encode(passwd_to_send),\
               #'username': self.username}
        #json_data = json.dumps(foo)
        self.create_http_tls_connection('POST', '/keygen', encrypted_passwd)"""

    def keygen(self, username):
        print("keygen")
        encrypted_username = self.encrypt_with_client_priv_key(username)
        foo = {'username': username,\
               'encryptedUsername':  encrypted_username}
        json_data = json.dumps(foo)
        self.create_http_tls_connection('POST', '/keygen', json_data)

    # /login
    def login(self):
        print("Client login")

        self.username = input('username: ')
        passwd = getpass.getpass('password: ')

        self.keygen(self.username)

        foo = {'username': self.username, "passwd": passwd}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/login', json_data)

    # /submit
    def submit(self, vuln_description, fingerprint):
        self.login()
        print("submit")

        foo = {'vulnDescription': vuln_description, 'fingerprint': fingerprint}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/submit', json_data)

    # /show
    def show(self):
        self.login()
        print("show")
        """foo = {'show': "ola"}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/show', json_data)"""

    # /score
    def score(self):
        self.login()
        print("score")

    # /admin/remove_user
    def remove_user(self):
        self.login()
        print("admin : remove_user")

    # /admin/remove_submission
    def remove_submission(self):
        self.login()
        print("admin : remove_submission")


def error(message):
    print("error: {}".format(message))
    sys.exit(1)


def main():

    client = Client()

    description = 'Welcome to the Vulnerability Submission Platform\n\
    register   Register new client account\n\
    submit     Submit vulnerability\n\
    show       Show submissions\n\
    score      Show scores\n'

    usage = '\n\
    client <command> [<args>]\n\
    client register\n\
    client submit <vuln_description> <fingerprint>\n\
    client show\n\
    client score\n'

    parser = argparse.ArgumentParser(prog='client', description=description,
                                     usage=usage, formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', type=str, choices=['register', 'submit', 'show', 'score'])
    parser.add_argument('vuln_description', nargs='?')
    parser.add_argument('fingerprint', nargs='?')

    args = parser.parse_args()

    if args.command.__eq__('register'):
        client.register()
    elif args.command.__eq__('submit'):
        if args.vuln_description and args.fingerprint:
            client.submit(args.vuln_description, args.fingerprint)
        else:
            parser.error('wrong arguments for submit command')
    elif args.command.__eq__('show'):
        client.show()
    elif args.command.__eq__('score'):
        client.score()


if __name__ == "__main__":
    main()