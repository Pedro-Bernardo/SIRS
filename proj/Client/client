#!/usr/bin/python3
import argparse
from argparse import RawTextHelpFormatter
import sys
import getpass
import ssl
import http.client
import json

# generate secure random numbers
from secrets import randbits

from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_PSS
from Crypto.Hash import SHA256

from OpenSSL.crypto import (load_certificate, load_publickey, load_privatekey, dump_certificate, X509, X509Name, PKey)
from OpenSSL.crypto import (TYPE_RSA, FILETYPE_PEM, FILETYPE_ASN1 )

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding

from base64 import b64encode, b64decode, encodebytes

import hmac
import hashlib


class Client:

    SSL_DIR = 'ssl/'
    HOST_ADDR = '127.0.0.1'

    CA_CERT = SSL_DIR + 'ca.pem'
    SERVER_HTTP_CERT = SSL_DIR + 'server_tls.crt'
    CLIENT_PUB_KEY_SUBSTRING = '_public.pem'
    CLIENT_PRIV_KEY_SUBSTRING = '_private.pem'

    # Diffie-Hellman constants
    G = 16308619823141802043
    P = 67698572054823323968190430198898140425166346813366120209767078191542539756243
    # P = 137107582757175698770717454412245801822880987412056810011630034635311728845863360414226149634509215229761633670329211458649575623639268672553200337399194406650756924289847497941176898119552142893337098481981428687987824042031956469715267802308168423966432241527893292376814976597763350723121374845794843670621

    # Diffie-Hellman secret values
    # Sc - client secret value
    Sc = None

    # Diffie-Hellman keys
    # Kc - client key
    Kc = None
    # Ks - server key
    Ks = None
    # K - key secret value
    K = None

    server_iv = None
    client_iv = None

    # loads certificates from CA for tls and server for http
    def __init(self):
        with open(self.CA_CERT, "r") as ca_cert_file:
            ca_cert_txt = ca_cert_file.read()
        self.ca_cert = load_certificate(FILETYPE_PEM, ca_cert_txt)

        with open(self.SERVER_HTTP_CERT, "r") as server_cert_file:
            server_cert_txt = server_cert_file.read()
        self.server_http_cert = load_certificate(FILETYPE_PEM, server_cert_txt)

        self.verify_certificate_chain()

    def verify_certificate_chain(self):
        # Create a certificate store and add your trusted certs (CA)
        try:
            store = crypto.X509Store()
            store.add_cert(self.ca_cert)

            # Create a certificate context using the store and the http server certificate
            store_ctx = crypto.X509StoreContext(store, self.server_http_cert)

            # Verify the certificate, returns None if it can validate the certificate
            store_ctx.verify_certificate()

            return True

        except Exception as e:
            print(e)
            return False

    def create_http_tls_connection(self, method, endpoint, json_data):
        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=self.CA_CERT)
        # check if hostname == CA
        ssl.match_hostname = lambda cert, hostname: True

        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPSConnection(self.HOST_ADDR, context=context)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        print("Server https response: {}".format(response.read().decode()))

        return response

    def create_http_connection(self, method, endpoint, json_data):
        headers = {'Content-type': 'application/json'}

        conn = http.client.HTTPConnection(self.HOST_ADDR)
        conn.request(method, endpoint, json_data, headers)

        response = conn.getresponse()
        response = response.read().decode()
        print("Server http response: {}".format(response))

        return json.loads(response)

    def encrypt_with_server_pub_key(self, message):
        server_pub_key = self.server_http_cert.get_pubkey().to_cryptography_key()

        # Optimal Asymmetric Encryption Padding (OAEP)
        return server_pub_key.encrypt(
                        message.encode('latin-1'),# ISO-8859-1
                        padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),
                                     algorithm=hashes.SHA256(),
                                     label=None))

    def hash_with_sha256_to_string(self, message):
        hashed_message = hashlib.sha256(message.encode())
        return hashed_message.hexdigest()

    """def hash_with_sha256(self, message):
        return hashlib.sha256(message.encode())"""

    def hmac_maker(self, hashed_passwd, encrypted_message):
        # hmac secret is hash(passwd)
        # hashed_passwd should be byte array and not str
        digest_maker = hmac.new(hashed_passwd.encode(), encrypted_message, hashlib.sha256)
        return digest_maker.hexdigest()

    """def sign_with_client_priv_key(self, username, hmac_message):
        with open(self.SSL_DIR + username + self.CLIENT_PRIV_KEY_SUBSTRING, "r") as priv_key_file:
            private_key = RSA.importKey(priv_key_file.read())

        signer = PKCS1_v1_5.new(private_key)

        #return signer.sign(self.hash_with_sha256(digest))
        return signer.sign(self.hash_with_sha256(hmac_message))"""

    def sign_with_client_priv_key(self, username, hmac_message):
        with open(self.SSL_DIR + username + self.CLIENT_PRIV_KEY_SUBSTRING, "r") as priv_key_file:
            private_key = RSA.importKey(priv_key_file.read())

        with open(self.SSL_DIR + username + self.CLIENT_PUB_KEY_SUBSTRING, "r") as server_cert_file:
            server_cert_txt = server_cert_file.read()
        publicKey = RSA.importKey(server_cert_txt)

        print("key {}".format(publicKey.export_key()))

        print("hmac {}".format(hmac_message))
        encoded_hmac = hmac_message.encode()
        #hashed_hmac = SHA256.new(encoded_hmac)
        hashed_hmac = SHA256.new()
        hashed_hmac.update(encoded_hmac)
        print("hashed hmac {}".format(hashed_hmac.hexdigest().encode()))

        return PKCS1_PSS.new(private_key).sign(hashed_hmac)

    def generate_diffie_hellman_secret_client_value(self):
        self.Sc = randbits(256)

    def generate_diffie_hellman_client_key(self):
        self.Kc = pow(self.G, self.Sc, self.P)

    def generate_diffie_hellman_secret_key(self):
        self.K = pow(self.Ks, self.Sc, self.P)

    #def decrypt_with_dh_symmetric_key(self, encrypted_message):


    def generate_key_pair(self, username):
        client_pub_key_path = self.SSL_DIR + username + self.CLIENT_PUB_KEY_SUBSTRING
        client_priv_key_path = self.SSL_DIR + username + self.CLIENT_PRIV_KEY_SUBSTRING

        key = RSA.generate(2048)
        f = open(client_priv_key_path, "wb")
        f.write(key.exportKey('PEM'))
        f.close()

        pubkey = key.publickey()
        f = open(client_pub_key_path, "wb")
        f.write(pubkey.exportKey('PEM'))
        f.close()

    # /register
    def register(self):
        print('New Client register')

        username = input('username (max 16 characters): ')
        if len(username) > 16:
            error('username has to be shorter than 16 characters')
        passwd = getpass.getpass('password (max 32 characters: ')
        if len(passwd) > 32:
            error('passwd has to be shorter than 32 characters')
        passwd_rep = getpass.getpass('repeat password: ')

        if passwd.__eq__(passwd_rep):
            self.generate_key_pair(username)
            # can we send pub key through tls ???????????

            hashed_passwd = self.hash_with_sha256_to_string(passwd)
            with open(self.SSL_DIR + username + self.CLIENT_PUB_KEY_SUBSTRING, "r") as pub_key_file:
                #public_key = RSA.importKey(pub_key_file.read())
                pub_key_text = pub_key_file.read()

            print("pubkey {} ".format(pub_key_text))

            json_encoded_public_key = b64encode(pub_key_text.encode()).decode()

            foo = {'username': username,
                   'hashedPasswd': hashed_passwd,
                   'publicKey': json_encoded_public_key}
            json_data = json.dumps(foo)
            self.create_http_tls_connection('POST', '/register', json_data)
        else:
            error('passwords do not match')

    # /login
    def login(self):
        print("Client login")

        username = input('username: ')
        passwd = getpass.getpass('password: ')

        self.generate_diffie_hellman_secret_client_value()
        self.generate_diffie_hellman_client_key()

        hashed_passwd = self.hash_with_sha256_to_string(passwd)

        # passwd or hash(password) ??????
        content = username + ',' + hashed_passwd + ',' + str(self.Kc)
        encrypted_content = self.encrypt_with_server_pub_key(content)

        # Sign(HMAC)
        hmac_integrity = self.hmac_maker(hashed_passwd, encrypted_content)
        signature = self.sign_with_client_priv_key(username, hmac_integrity)
        encoded_signature = b64encode(signature).decode()
        encoded_encrypted_content = b64encode(encrypted_content).decode('latin-1')

        foo = {'signature': encoded_signature,
               'hmac': hmac_integrity,
               'encryptedContent': encoded_encrypted_content}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/login', json_data)
        #response = self.create_http_connection('POST', '/login', json_data)
        #print("dhServerKey: {}".format(response['dhServerKey']))

        # process to generate key for client to encrypt following request message
        self.Ks = int(response['dhServerKey'])
        self.generate_diffie_hellman_secret_key()
        print("secret: {}".format(self.K))

        json_response = json.dumps(response)
        self.Ks = json_response['dhServerKey']
        print("Ks {}".format(self.Ks ))
        self.server_iv = json_response['iv']
        print("server iv {}".format(json_response))
        encrypted_content = json_response['encryptedContent']
        print('encrypted_content: {}'.format(encrypted_content))

    # /submit
    def submit(self, vuln_description, fingerprint):
        self.login()
        print("submit")

        foo = {'vulnDescription': vuln_description, 'fingerprint': fingerprint}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/submit', json_data)

    # /show
    def show(self):
        self.login()
        print("show")
        """foo = {'show': "ola"}
        json_data = json.dumps(foo)

        self.create_http_connection('POST', '/show', json_data)"""

    # /score
    def score(self):
        self.login()
        print("score")

    # /admin/remove_user
    def remove_user(self):
        self.login()
        print("admin : remove_user")

    # /admin/remove_submission
    def remove_submission(self):
        self.login()
        print("admin : remove_submission")


def error(message):
    print("error: {}".format(message))
    sys.exit(1)


def main():

    client = Client()

    description = 'Welcome to the Vulnerability Submission Platform\n\
    register   Register new client account\n\
    submit     Submit vulnerability\n\
    show       Show submissions\n\
    score      Show scores\n'

    usage = '\n\
    client <command> [<args>]\n\
    client register\n\
    client submit <vuln_description> <fingerprint>\n\
    client show\n\
    client score\n'

    parser = argparse.ArgumentParser(prog='client', description=description,
                                     usage=usage, formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', type=str, choices=['register', 'submit', 'show', 'score'])
    parser.add_argument('vuln_description', nargs='?')
    parser.add_argument('fingerprint', nargs='?')

    args = parser.parse_args()

    if args.command.__eq__('register'):
        client.register()
    elif args.command.__eq__('submit'):
        if args.vuln_description and args.fingerprint:
            client.submit(args.vuln_description, args.fingerprint)
        else:
            parser.error('wrong arguments for submit command')
    elif args.command.__eq__('show'):
        client.show()
    elif args.command.__eq__('score'):
        client.score()


    

if __name__ == "__main__":
    main()